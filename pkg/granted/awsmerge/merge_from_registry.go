// Package awsmerge contains logic to merge multiple AWS config files
// together. In Granted this is used to power the Profile Registry feature.
package awsmerge

import (
	"bytes"
	"fmt"
	"html/template"
	"regexp"
	"strings"

	"github.com/common-fate/clio"
	"github.com/common-fate/granted/pkg/cfaws"
	grantedConfig "github.com/common-fate/granted/pkg/config"
	"gopkg.in/ini.v1"
)

type RegistryOpts struct {
	Name                    string
	PrefixAllProfiles       bool
	PrefixDuplicateProfiles bool
}

type DuplicateProfileError struct {
	Name string
}

func (e DuplicateProfileError) Error() string {
	return fmt.Sprintf("duplicate profile found: %s", e.Name)
}

func autoGeneratedMsg() string {
	messages := []string{
		"# Auto-generated by Granted (https://granted.dev). DO NOT EDIT.",
		"# Manual edits to this section will be overwritten.",
		"# To stop syncing and remove this section, run 'granted registry remove'.",
	}

	return strings.Join(messages, "\n")
}

// WithRegistry merges AWS profiles from 'src' into the 'dst' INI config.
//
// It applies a range around the generated profiles as follows:
//
//	[granted_registry_start test]
//	// ... <generated profiles>
//	[granted_registry_end test]
func WithRegistry(src *ini.File, dst *ini.File, opts RegistryOpts) (*ini.File, error) {
	namespace := opts.Name

	// create a temporary ini structure, so that we leave 'dst' untouched if we run into
	// an error halfway through merging.

	tmp := ini.Empty()

	for _, section := range dst.Sections() {
		f, err := tmp.NewSection(section.Name())
		if err != nil {
			return nil, err
		}
		err = copySection(copySectionOpts{
			Src: section,
			Dst: f,
		})
		f.Comment = section.Comment
		if err != nil {
			return nil, err
		}
	}

	// replace any existing generated profiles which match the name of the registry
	existing := getGrantedGeneratedSections(tmp, opts.Name)
	for _, p := range existing {
		tmp.DeleteSection(p.Name())
	}

	clio.Debugf("generating section %s", namespace)

	header := "granted_registry_start " + namespace

	err := tmp.NewSections(header) // adds a block `[granted_registry_start <namespace>]` to the INI
	if err != nil {
		return nil, err
	}

	// add "do not edit" msg in the top of autogenerated code.
	tmp.Section(header).Comment = autoGeneratedMsg()

	currentProfiles := tmp.SectionStrings()

	// iterate each profile section from cloned repo
	// add them to aws config file
	// if there is a collision in the profile names then prefix with namespace.
	for _, sec := range src.Sections() {
		if sec.Name() == ini.DefaultSection {
			continue
		}

		// All sections that start with 'profile' prefix will be considered as AWS profiles and will be verified
		// 1. if they have a correct profile name
		// 2. if they have duplicate profile names i.e if the new profile name already exists on the aws config file
		// For any other section, copy the content as it is.
		isAProfile := strings.Contains(sec.Name(), "profile")

		if !isAProfile {
			// any other section is copied as it is.
			f, err := tmp.NewSection(sec.Name())
			if err != nil {
				return nil, err
			}

			err = copySection(copySectionOpts{
				Src:                  sec,
				Dst:                  f,
				InterpolateVariables: true,
			})
			if err != nil {
				return nil, err
			}

			f.Comment = sec.Comment
			continue
		}

		isLegalName := cfaws.IsLegalProfileName(strings.TrimPrefix(sec.Name(), "profile "))

		if !isLegalName {
			clio.Warnf("profile name %s is invalid", sec.Name())
			continue
		}

		if opts.PrefixAllProfiles {
			f, err := tmp.NewSection(appendNamespaceToDuplicateSections(sec.Name(), namespace))
			if err != nil {
				return nil, err
			}

			err = copySection(copySectionOpts{
				Src:                  sec,
				Dst:                  f,
				InterpolateVariables: true,
			})
			if err != nil {
				return nil, err
			}

			continue
		}

		isDuplicate := contains(currentProfiles, sec.Name())

		if !isDuplicate {
			f, err := tmp.NewSection(sec.Name())
			if err != nil {
				return nil, err
			}

			err = copySection(copySectionOpts{
				Src:                  sec,
				Dst:                  f,
				InterpolateVariables: true,
			})
			if err != nil {
				return nil, err
			}
			continue
		}

		// if we get here, the profile name is a duplicate of an existing profile in the AWS config file.

		// if we don't prefix duplicates, return an error
		if !opts.PrefixDuplicateProfiles {
			return nil, DuplicateProfileError{Name: sec.Name()}
		}

		clio.Debugf("prefixing %s to avoid collision", sec.Name())
		f, err := tmp.NewSection(appendNamespaceToDuplicateSections(sec.Name(), namespace))
		if err != nil {
			return nil, err
		}

		err = copySection(copySectionOpts{
			Src:                  sec,
			Dst:                  f,
			InterpolateVariables: true,
		})
		if err != nil {
			return nil, err
		}

		// after the section has been copied, update the credential process if it exists to the new profile name

		if f.HasKey("credential_process") {
			f.Key("credential_process").SetValue(strings.Replace(f.Key("credential_process").Value(), sec.Name(), f.Name(), 1))
		}

		if f.Comment == "" {
			f.Comment = "# profile name has been prefixed due to duplication"
		} else {
			f.Comment = "# profile name has been prefixed due to duplication. \n" + sec.Comment
		}
	}

	// footer section
	err = tmp.NewSections("granted_registry_end " + namespace)
	if err != nil {
		return nil, err
	}

	return tmp, nil
}

func contains(arr []string, s string) bool {
	for _, v := range arr {
		if v == s {
			return true
		}
	}

	return false
}

func appendNamespaceToDuplicateSections(pName string, namespace string) string {
	regx := regexp.MustCompile(`(.*profile\s+)(?P<name>[^\n\r]*)`)

	if regx.MatchString(pName) {
		matches := regx.FindStringSubmatch(pName)
		nameIndex := regx.SubexpIndex("name")

		return "profile " + namespace + "." + matches[nameIndex]
	}

	return pName
}

type copySectionOpts struct {
	Src                  *ini.Section
	Dst                  *ini.Section
	InterpolateVariables bool
}

// copy section content from source profile to destination profile.
func copySection(opts copySectionOpts) error {
	for _, key := range opts.Src.KeyStrings() {
		iniKey := opts.Src.Key(key)
		value := opts.Src.Key(key).Value()

		// check if the value contains go-template
		if opts.InterpolateVariables && containsTemplate(value) {
			output, err := interpolateVariables(value, strings.TrimPrefix(opts.Dst.Name(), "profile "))
			if err != nil {
				return err
			}

			k, err := opts.Dst.NewKey(key, output)
			if err != nil {
				return err
			}
			k.Comment = iniKey.Comment

		} else {
			k, err := opts.Dst.NewKey(key, opts.Src.Key(key).Value())
			if err != nil {
				return err
			}
			k.Comment = iniKey.Comment
		}
	}

	return nil
}

type configTemplateVars struct {
	Required  map[string]string
	Variables map[string]string
	Profile   string
}

func interpolateVariables(value string, profileName string) (string, error) {
	gConf, err := grantedConfig.Load()
	if err != nil {
		return "", err
	}

	d := configTemplateVars{
		Variables: gConf.ProfileRegistry.Variables,
		Required:  gConf.ProfileRegistry.RequiredKeys,
		Profile:   profileName,
	}

	tmpl, err := template.New("registry-variable").Parse(value)
	if err != nil {
		return "", err
	}

	buf := &bytes.Buffer{}
	err = tmpl.Execute(buf, d)
	if err != nil {
		panic(err)
	}
	return buf.String(), nil
}

func containsTemplate(text string) bool {
	re := regexp.MustCompile(`{{\s*(.\w+){1,2}\s*}}`)

	return re.MatchString(text)
}

func getGrantedGeneratedSections(config *ini.File, name string) []*ini.Section {
	var grantedProfiles []*ini.Section

	header := "granted_registry_start " + name
	footer := "granted_registry_end " + name

	isAutogeneratedSection := false
	for _, section := range config.Sections() {
		name := section.Name()

		if name == ini.DefaultSection {
			continue
		}

		if name == header && !isAutogeneratedSection {
			isAutogeneratedSection = true
			grantedProfiles = append(grantedProfiles, section)

			continue
		}

		if name == footer {
			grantedProfiles = append(grantedProfiles, section)
			return grantedProfiles
		}

		if isAutogeneratedSection {
			grantedProfiles = append(grantedProfiles, section)
		}
	}

	return grantedProfiles
}
